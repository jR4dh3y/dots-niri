#!/usr/bin/env python3
import sys, os
import argparse
from PIL import Image
import colorsys
from collections import Counter
import math
from materialyoucolor.quantize import QuantizeCelebi
from materialyoucolor.score.score import Score

import hashlib

home = os.path.expanduser("~")
current = f"{home}/.cache/wallpaper.colors"
cache_dir = (
    f"{home}/.cache/colorscheme"  # cache dir contains cache of colorschemes for files
)

if not os.path.exists(cache_dir):
    os.makedirs(cache_dir)


def extract_dominant_colors(image_path, num_colors=6):
    """Extract dominant colors from an image using Material You quantization."""
    try:
        # Open image
        image = Image.open(image_path)

        # Convert to RGB if necessary
        image = image.convert("RGB")

        # Get image data
        pixel_len = image.width * image.height
        image_data = image.getdata()

        # Quality 1 means skip no pixels
        quality = os.environ.get("MYC_QUALITY", "4")
        quality = int(quality) if quality.isdigit() else 4
        pixel_array = [image_data[_] for _ in range(0, pixel_len, quality)]

        # Run Material You quantization algorithm
        result = QuantizeCelebi(pixel_array, 128)  # 128 -> number desired colors

        # Score and select the best colors
        scored_colors = Score.score(result)

        # Convert integer colors to RGB tuples
        colors = []
        for color_int in scored_colors[:num_colors]:
            # Convert from ARGB integer to RGB tuple
            r = (color_int >> 16) & 0xFF
            g = (color_int >> 8) & 0xFF
            b = color_int & 0xFF
            colors.append((r, g, b))

        return colors
    except Exception as e:
        print(f"Error processing image: {e}", file=sys.stderr)
        return []


def rgb_to_hex(rgb):
    """Convert RGB tuple to hex string."""
    return f"{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}"


def rgb_to_hsl(rgb):
    """Convert RGB to HSL."""
    r, g, b = [x / 255.0 for x in rgb]
    return colorsys.rgb_to_hls(r, g, b)


def hsl_to_rgb(h, s, l):
    """Convert HSL to RGB."""
    r, g, b = colorsys.hls_to_rgb(h, l, s)
    return tuple(int(x * 255) for x in (r, g, b))


def adjust_lightness(rgb, factor):
    """Adjust the lightness of an RGB color."""
    h, l, s = rgb_to_hsl(rgb)
    l = max(0, min(1, l * factor))
    return hsl_to_rgb(h, s, l)


def adjust_saturation(rgb, factor):
    """Adjust the saturation of an RGB color."""
    h, l, s = rgb_to_hsl(rgb)
    s = max(0, min(1, s * factor))
    return hsl_to_rgb(h, s, l)


def generate_material_you_palette(primary_color):
    """Generate Material You color palette from a primary color."""

    # Base catppuccin-inspired colors (can be customized)
    base_colors = {
        "rosewater": (242, 213, 207),
        "flamingo": (238, 190, 190),
        "pink": (244, 184, 228),
        "mauve": (202, 158, 230),
        "red": (231, 130, 132),
        "maroon": (234, 153, 156),
        "peach": (239, 159, 118),
        "yellow": (229, 200, 144),
        "green": (166, 209, 137),
        "teal": (129, 200, 190),
        "sky": (153, 209, 219),
        "sapphire": (133, 193, 220),
        "blue": (140, 170, 238),
        "lavender": (186, 187, 241),
    }

    # Generate surfaces based on primary color
    primary_hsl = rgb_to_hsl(primary_color)

    # Dark theme surfaces
    surfaces = {
        "text": (198, 208, 245),
        "subtext1": (181, 191, 226),
        "subtext0": (165, 173, 206),
        "overlay2": (148, 156, 187),
        "overlay1": (131, 139, 167),
        "overlay0": (115, 121, 148),
        "surface2": (98, 104, 128),
        "surface1": (81, 87, 109),
        "surface0": (65, 69, 89),
        "base": (48, 52, 70),
        "mantle": (41, 44, 60),
        "crust": (35, 38, 52),
    }

    # Material You system colors
    material_colors = {
        "success": base_colors["green"],
        "primary_paletteKeyColor": primary_color,
        "secondary_paletteKeyColor": adjust_saturation(primary_color, 0.7),
        "tertiary_paletteKeyColor": adjust_lightness(primary_color, 0.8),
        "neutral_paletteKeyColor": adjust_saturation(primary_color, 0.1),
        "neutral_variant_paletteKeyColor": adjust_saturation(primary_color, 0.2),
        # Background colors
        "background": (18, 19, 24),
        "onBackground": (227, 225, 233),
        "surface": (18, 19, 24),
        "surfaceDim": (18, 19, 24),
        "surfaceBright": (56, 57, 63),
        "surfaceContainerLowest": (13, 14, 19),
        "surfaceContainerLow": (26, 27, 33),
        "surfaceContainer": (30, 31, 37),
        "surfaceContainerHigh": (41, 42, 47),
        "surfaceContainerHighest": (52, 52, 58),
        "onSurface": (227, 225, 233),
        "surfaceVariant": (69, 70, 79),
        "onSurfaceVariant": (198, 197, 208),
        "inverseSurface": (227, 225, 233),
        "inverseOnSurface": (47, 48, 54),
        "outline": (144, 144, 154),
        "outlineVariant": (69, 70, 79),
        "shadow": (0, 0, 0),
        "scrim": (0, 0, 0),
        "surfaceTint": adjust_lightness(primary_color, 1.2),
        # Primary colors
        "primary": adjust_lightness(primary_color, 1.1),
        "onPrimary": adjust_lightness(primary_color, 0.3),
        "primaryContainer": adjust_lightness(primary_color, 0.7),
        "onPrimaryContainer": adjust_lightness(primary_color, 1.3),
        "inversePrimary": adjust_lightness(primary_color, 0.8),
        # Secondary colors
        "secondary": adjust_saturation(adjust_lightness(primary_color, 1.0), 0.6),
        "onSecondary": adjust_lightness(primary_color, 0.4),
        "secondaryContainer": adjust_lightness(primary_color, 0.5),
        "onSecondaryContainer": adjust_lightness(primary_color, 1.2),
        # Tertiary colors
        "tertiary": adjust_lightness(primary_color, 0.9),
        "onTertiary": adjust_lightness(primary_color, 0.3),
        "tertiaryContainer": adjust_lightness(primary_color, 0.6),
        "onTertiaryContainer": (0, 0, 0),
        # Error colors
        "error": (255, 180, 171),
        "onError": (105, 0, 5),
        "errorContainer": (147, 0, 10),
        "onErrorContainer": (255, 218, 214),
        # Fixed colors
        "primaryFixed": adjust_lightness(primary_color, 1.3),
        "primaryFixedDim": adjust_lightness(primary_color, 1.1),
        "onPrimaryFixed": adjust_lightness(primary_color, 0.2),
        "onPrimaryFixedVariant": adjust_lightness(primary_color, 0.7),
        "secondaryFixed": adjust_lightness(primary_color, 1.2),
        "secondaryFixedDim": adjust_saturation(
            adjust_lightness(primary_color, 1.0), 0.6
        ),
        "onSecondaryFixed": adjust_lightness(primary_color, 0.25),
        "onSecondaryFixedVariant": adjust_lightness(primary_color, 0.6),
        "tertiaryFixed": (255, 215, 245),
        "tertiaryFixedDim": adjust_lightness(primary_color, 0.9),
        "onTertiaryFixed": adjust_lightness(primary_color, 0.2),
        "onTertiaryFixedVariant": adjust_lightness(primary_color, 0.5),
    }

    # Combine all colors
    all_colors = {**base_colors, **surfaces, **material_colors}

    return all_colors


def compute_file_hash(file_path, algorithm="sha256"):
    """Compute the hash of a file using the specified algorithm."""
    hash_func = hashlib.new(algorithm)

    with open(file_path, "rb") as file:
        # Read the file in chunks of 8192 bytes
        while chunk := file.read(8192):
            hash_func.update(chunk)

    return hash_func.hexdigest()


def create_color_scheme(image_path):
    """Extract colors from image and print in Material You format."""

    file_hash = compute_file_hash(image_path)
    cache_path = f"{cache_dir}/{file_hash}.colors"

    if os.path.exists(cache_path):
        # copy cached file
        os.system(f"cp {cache_path} {current}")
        return True

    dominant_colors = extract_dominant_colors(image_path)

    if not dominant_colors:
        print("Failed to extract colors from image", file=sys.stderr)
        return False

    # Use the most dominant color as primary
    primary_color = dominant_colors[0]

    # Generate full palette
    palette = generate_material_you_palette(primary_color)
    out_str = ""
    for name, rgb in palette.items():
        hex_color = rgb_to_hex(rgb)
        out_str += f"{name} {hex_color}\n"
    with open(cache_path, "w") as f:
        f.write(out_str)

    os.system(f"cp {cache_path} {current}")
    return True


def main():
    parser = argparse.ArgumentParser(
        description="Extract Material You color scheme from image"
    )
    parser.add_argument("image_path", help="Path to the image file")

    args = parser.parse_args()

    if not create_color_scheme(args.image_path):
        sys.exit(1)


if __name__ == "__main__":
    main()
